\section{Insert-First-Verfahren} \label{sec:insert-first-verfahren}
% Was ist das Min Dist Verfahren?
    % Nodes werden in der Reihenfolge ihres Auftretens in den Graphen eingefügt
    % Insert-First = dadurch insert-random  
% Wie funktioniert es
    % Ein neuer Graph mit einem Pfad der länge n wird erzeugt
    % Die Nodes des Pfades des Graphen seien Y1,Y2,Y3,Y4...
    % Die erst Node des Pfads wird mit der ersten Node in der Liste der Verfügbaren Nodes befüllt (= Ausgangs-Node)
    % Die zweite Node wird ebenso aus den verfügbaren Nodes angehängt (ist nun an zweiter Stelle)
    % Nun wird durch die restlichen Verfügbaren Nodes iteriert
    % Node X sei Gegenstand des momentanen Iterationdurchlaufs 
    % Für X wird beginnend mit Y2 die Distanz zwischen Yn-1 und X + Distanz zwischen Yn und X errechnet
    % resultierend aus diesen Berechnungen wird die beste Stelle gesucht, um X in den Pfad einzufügen
% Teile des Quellcodes zeigen

Das Insert-First-Verfahren ist ein heuristischer Lösungsansatz des \ac{TSP}s, bei dem das Betrachten der Knoten zum Aufbau eines Graphen in zufälliger Reihenfolge, bzw. in der Reihenfolge ihrer Erzeugung geschieht.
Dabei wird zu einem Zeitpunkt genau ein Knoten betrachtet und an der für ihn bestmöglichen Stelle in den bereits bestehenden Graphen eingefügt.

\subsection{Funktionsweise}
Zu Beginn des Insert-First-Verfahrens wird ein neuer Graph erzeugt, welcher als Eingabewerte eine Liste mit den Knoten $K_1, K_2,  \ldots ,K_n$, hier bezeichnet als \lstinline{nodes} und der Länge $n$ erhält. 
Jeder Graph ist mit einem Pfad (oder auch \lstinline{path}) der Länge $n$ assoziiert, der die Reihenfolge der Knoten bestimmt. 
Nun wird $K_1$, der erste Knoten aus der übergebenen Liste in den Pfad des Graphs an erster Stelle eingefügt. 
Dies geschieht so oder ähnlich bei allen Verfahren, um einen statischen Ausgangspunkt zu gewährleisten und somit vergleichbare Ergebnisse zu erzielen.
Anschließend wird noch der zweite Knoten, $K_2$ angehängt.

\begin{lstlisting}[caption={Zuweisung des ersten und zweiten Knotens}]
path[0] = nodes[0];
path[1] = nodes[1];  
\end{lstlisting}

Das Vorgehen für das Einfügen der restlichen Knoten lässt sich wie folgt beschreiben: 
Sei $G$ ein Graph mit übergebener Liste von Knoten  $K_1,\ldots,K_n$ und bereits teilweise befülltem Pfad $K_1,\ldots,K_m$ mit $2 > m < n$.
Die Knoten, die noch eingefügt werden müssen, werden in der Reihenfolge ihres Auftretens in der übergebenen Liste in den Graphen eingefügt, womit der als nächstes einzufügende Knoten immer $K_{i}$ mit $i = m + 1$ ist.
\\
Um die beste Stelle zu ermitteln, in die $K_i$ eingefügt werden soll, wird für jede mögliche Stelle die Distanzerhöhung berechnet, zu der das Einfügen von $K_i$ an dieser Stelle führen würde.
Um die beste Stelle zu ermitteln, in die $K_i$ eingefügt werden soll, wird für jeden möglichen Index, also jede mögliche Stelle, die Gesamtdistanz des entstehenden Graphen berechnet. 
% Aus den so berechneten Möglichkeiten wird die mit der geringsten Distanz vermerkt und ausgewählt.
% % Um die Stelle zu ermitteln, in die $K_i$ eingefügt werden soll, müssen die Distanzen zu Vorgänger und Nachfolger berechnet und die geringste Entfernung ermittelt werden. 
% % Hierzu wird durch die Knoten beginnend mit $K_2$ bis $K_{m+1}$ iteriert. Dabei sei $K_j$ der Knoten des aktuellen Iterationdurchlaufs. 
% % Nun wird die Distanz zwischen $K_{j-1}$ und $K_i$ mit der Distanz zwischen  $K_{j}$ und $K_i$ addiert. Hierbei muss beachtet werden, dass bei der Betrachtung von $K_{j=m+1}$ keine wirkliche Distanz zu $K_i$ errechnet werden kann, da nur $m$ Knoten im Graphen sind. Stattdessen wird angenommen, dass die Distanz 0 beträgt, sodass ein Anfügen an das Ende des Graphen simuliert wird.
% \\
% In Java Quellcode bedeutet dies konkret:
% \begin{lstlisting}[caption={Ermittlung der Distanzen}, label={lst:distjava}]
% double currentDistance = 
%     ((path[j] != null) ? distances.getDistanceById(path[j], nodes[i]) : 0)
%     + distances.getDistanceById(path[j - 1], nodes[i]);

% \end{lstlisting}
Das niedrigste Ergebnis dieser Möglichkeiten wird zusammen mit dem dazugehörigen Index $j$ vermerkt. 
Nachdem die niedrigste Distanz für $K_i$ errechnet wurde kann anhand des Index' der Knoten an der bestmöglichen Stelle in den Graphen eingefügt werden. 
Einfügen bedeutet hier, dass alle Knoten, deren Index gleich oder höher $j$ ist nach hinten verschoben werden. 
Nachdem alle Knoten auf diese Weise nach hinten verschoben wurden, kann $K_i$ an der Stelle $j$ eingefügt werden, ohne, dass andere Knoten verloren gehen. 
Konkret sieht das im Java Quellcode wie folgt aus:
\begin{lstlisting}[caption={Einfügen von Knoten in einen bestehenden Graph}, label={code:mergeIntojava}]
private static Node[] mergeNodeIntoGraph(Node[] path, Node node, int index) {
    for (int i = path.length - 2; i >= index; i--) {
        path[i + 1] = path[i];
    }
    path[index] = node;
    return path;
}
\end{lstlisting}
Beispielhaft sähe das mit den vorher festgelegten Bezeichnungen wie folgt aus: 
\begin{addmargin}[1em]{2em}
\lstinline{path = } $K_1, K_2, K_4, K_3$ und $K_{i = 5}$ 
\end{addmargin}
Durch das ermitteln der Gesamtdistanzen in Abhängigkeit zu den möglichen Einfügestellen wird bekannt, dass $K_{i=5}$ mit dem Index $j=4$, also zwischen $K_4$ und $K_3$ bestmöglich eingefügt werden kann. 
Durch das Einfügen nach \vref{code:mergeIntojava} entsteht folgender Pfad:
\begin{addmargin}[1em]{2em}
\lstinline{path = } $K_1, K_2, K_4, K_5, K_3$
\end{addmargin}
für den Graphen.

\subsection{Ergebnisse und Schwächen} \label{sec:inserst-first-erg}
Bevor einige durch den Algorithmus generierte Beispiele betrachtet werden, wird hier das Szenario dieser und aller folgender Beispiele, es sei denn ist anderes angegeben, beschrieben.
Alle gezeigten Knoten befinden sich auf einem zweidimensionalem Fläche mit den Maßen zehn mal zehn \ac{LE}.
Folglich kann jedem Knoten eine X- und Y-Koordinate zwischen jeweils null und zehn zugeordnet werden. 
Dementsprechend bewegen sich auch die Gesamtdistanzen er gezeigten Graphen in dieser Größenordnung.
Weiterhin werden aus Gründen der Übersichtlichkeit für den Großteil der folgenden Beispiele nur Graphen mit fünf Knoten betrachtet.
\\\\
Bei dem Einsatz des oben beschriebenen Algorithmus kommt es zu Ergebnissen, die in ihrer Qualität nah an die optimale Lösung herankommen, teilweise aber auch weit von ihr abweichen können.  

\begin{figure}[H]
    \begin{center}
        \subfloat[$m = 2$\label{subfig:insert-first-BAD-m2}]{%
        \includegraphics[width=0.35\textwidth]{./Bilder/insertFirst/insert_first_BAD_ex_1.PNG}
        }
        \hfil
        \subfloat[$m = 3$\label{subfig:insert-first-BAD-m3}]{%
        \includegraphics[width=0.35\textwidth]{./Bilder/insertFirst/insert_first_BAD_ex_2.PNG}
        }
        \\
        \subfloat[$m = 4$\label{subfig:insert-first-BAD-m4}]{%
        \includegraphics[width=0.35\textwidth]{./Bilder/insertFirst/insert_first_BAD_ex_3.PNG}
        }
        \hfil
        \subfloat[$m = 5$\label{subfig:insert-first-BAD-m5}]{%
        \includegraphics[width=0.35\textwidth]{./Bilder/insertFirst/insert_first_BAD_ex_4.PNG}
        }
        \caption{Insert-First führt zu schlechtem Ergebnis}
        \label{fig:insert-first-bad}
    \end{center}
\end{figure}

% TODO: Alle Schritte/Bilder in den Anhang
Auf \vref{subfig:insert-first-BAD-m4} lässt sich erkennen, dass das Einfügen des vierten Knoten $K_4$ nicht optimal geschieht. 
Besser für $m = 4$ wäre hier der Pfad 
\begin{addmargin}[1em]{2em}
    \lstinline{path = } $K_1, K_3, K_2, K_4$. 
    \end{addmargin}
Dieser wird allerdings nicht durch das Insert-First-Verfahren gebildet, da dies eine Änderung des bereits erzeugten Graphen in \vref{subfig:insert-first-BAD-m3} erfordern würde. 
Dies ist jedoch nicht möglich, da $K_4$ nur zwischen bereits im Pfad des Graphen vorhandenen Knoten eingefügt werden kann, sodass der schlussendlich generierte Graph eine Gesamtlänge von 15,945 \ac{LE} hat.
Hier lässt sich auch das grundlegende Problem des Algorithmus erkennen: Das Erstellen einer Route ohne vorherige Betrachtung der Gesamtheit der Knoten. 
Einzelne Teilschritte des Graphen können gut erzeugt werden, wie beispielsweise im Schritt von \vref{subfig:insert-first-BAD-m2} zu \vref{subfig:insert-first-BAD-m3}. 
Andere hingegen, wie vorher erwähnt, nicht. 
Grund hierfür ist die alleinige Betrachtung des Knotens $K_i$. 
Spezifischer bedeutet das, dass das frühe Einfügen von Knoten in den Pfad eines Graphen später zu Komplikationen führen kann, da es objektiv besser gewesen wäre einen anderen Knoten früher einzufügen.
Am konkreten Beispiel führt die generierte Reihenfolge von 
\begin{addmargin}[1em]{2em}
    \lstinline{path = } $K_1, K_2, K_3$. 
    \end{addmargin}
in \vref{subfig:insert-first-BAD-m3} dazu, dass $K_4$ nur unter einen vergleichsweise großen Gesamtdistanzzuwachs in den Graphen eingefügt werden kann. 
\\\\
Konträr zu diesem schlechten Beispiel ist der Insert-First-Algorithmus auch in der Lage gute bis optimale Ergebnisse zu generieren. 

\begin{figure}[H]
    \begin{center}
        \subfloat[$m = 2$\label{subfig:insert-first-GOOD-m2}]{%
        \includegraphics[width=0.35\textwidth]{./Bilder/insertFirst/insert_first_ex_1.PNG}
        }
        \hfil
        \subfloat[$m = 3$\label{subfig:insert-first-GOOD-m3}]{%
        \includegraphics[width=0.35\textwidth]{./Bilder/insertFirst/insert_first_ex_2.PNG}
        }\\
        \subfloat[$m = 4$\label{subfig:insert-first-GOOD-m4}]{%
        \includegraphics[width=0.35\textwidth]{./Bilder/insertFirst/insert_first_ex_3.PNG}
        }
        \hfil
        \subfloat[$m = 5$\label{subfig:insert-first-GOOD-m5}]{%
        \includegraphics[width=0.35\textwidth]{./Bilder/insertFirst/insert_first_ex_4.PNG}
        }
        \caption{Insert-First führt zu guten Ergebnis}
        \label{fig:insert-first-good}
    \end{center}
\end{figure}
% TODO: Alle Schritte/Bilder in den Anhang

Am Beispiel in \vref{fig:insert-first-good} lässt sich erkennen, wie der Insert-First-Algorithmus einen optimalen Pfad mit den gegebenen Knoten generiert. 
Gerade im Schritt von \vref{subfig:insert-first-GOOD-m4} zu \vref{subfig:insert-first-GOOD-m5} ist ein funktionierendes und korrektes Einfügen des Knotens in den Graphen zu sehen, bei dem der Anstieg der Gesamtdistanz der Route sehr gering gehalten wird. 
Hier wird der aktuelle Knoten mit geringem Zuwachs der schlussendlichen Gesamtdistanz in den Graphen eingefügt, sodass die Gesamtdistanz zum Ende bei 16,691 \ac{LE} liegt.
Die scheint zwar höher als das vorherige schlechte beispiel, das liegt aber an den Positionen der einzelnen Knoten.
\\\\
Für die Bewertung des Algorithmus müssen also beide Seiten betrachtet werden. 
Zwar ist Insert-First in der Lage eine gute oder auch optimale Route zu erstellen, allerdings beeinflusst die Reihenfolge der Betrachtung der Knoten stark die Qualität des Endergebnisses.